package models;

import utils.StringUtil;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;

/**
 * Block Class - The Building Block of a Blockchain
 * ================================================
 * Think of a blockchain as a chain of boxes (blocks), where each box:
 * 1. Contains transactions (like a ledger page)
 * 2. Has a unique fingerprint (hash)
 * 3. Points to the previous box (previousHash)
 * 4. Is sealed using mining (proof-of-work)
 *
 * This immutable link creates an unbreakable chain - changing one block
 * would require recalculating all subsequent blocks!
 */
public class Block {

    // ============================================================
    // BLOCK HEADER - Meta information about the block
    // ============================================================

    /**
     * index: Position of this block in the blockchain
     * Example: Block #0 (Genesis), Block #1, Block #2, etc.
     * Like page numbers in a book - helps maintain order
     */
    private int index;

    /**
     * timestamp: When this block was created (in milliseconds since 1970)
     * Important for: ordering events, calculating mining time, auditing
     * Example: 1698234567890 (represents a specific date/time)
     */
    private long timestamp;

    /**
     * hash: This block's unique fingerprint/identifier
     * Generated by combining all block data and running SHA-256
     * Example: "000012ab34cd..." (64 characters in hexadecimal)
     * If ANYTHING in the block changes, this hash changes completely!
     */
    private String hash;

    /**
     * previousHash: The hash of the block that came before this one
     * This creates the "chain" in blockchain! Each block points backwards
     * Example: Block #5 contains the hash of Block #4
     * Special case: Genesis block (first block) has previousHash = "0"
     */
    private String previousHash;

    /**
     * nonce: "Number used ONCE" - a random number for mining
     * Miners keep changing this number until the block's hash meets difficulty
     * Example: After trying nonce = 0, 1, 2, ... 47,582, we finally get valid hash
     * This is the "proof" in "proof-of-work" - proof that work was done!
     */
    private int nonce;

    // ============================================================
    // BLOCK BODY - The actual content/data of the block
    // ============================================================

    /**
     * transactions: List of all transactions stored in this block
     * Example: ["Alice pays Bob 5 BTC", "Carol pays Dave 2 BTC"]
     * Like entries on a ledger page - once written, cannot be erased
     */
    private List<Transaction> transactions;

    /**
     * merkleRoot: A single hash representing ALL transactions
     * Uses Merkle Tree structure - efficient way to verify transactions
     *
     * How it works (simplified):
     * If we have 4 transactions [T1, T2, T3, T4]:
     * 1. Hash pairs: H(T1+T2) and H(T3+T4)
     * 2. Hash results: H( H(T1+T2) + H(T3+T4) )
     * 3. Final result = Merkle Root
     *
     * Benefit: Can verify a transaction is in block without downloading all transactions!
     */
    private String merkleRoot;

    /**
     * Constructor - Create a new block (like starting a new page in ledger)
     *
     * @param index - Position in blockchain (0 for genesis, 1 for next, etc.)
     * @param previousHash - Hash of the previous block (creates the chain link)
     * @param transactions - List of transactions to include in this block
     *
     * Process:
     * 1. Record the block number (index)
     * 2. Link to previous block (previousHash)
     * 3. Copy transactions safely (defensive programming)
     * 4. Record creation time (timestamp)
     * 5. Start nonce at 0 (will be incremented during mining)
     * 6. Calculate merkle root (fingerprint of all transactions)
     * 7. Calculate initial hash (will change during mining)
     */
    public Block(int index, String previousHash, List<Transaction> transactions) {
        this.index = index;
        this.previousHash = previousHash;

        // Create a COPY of transactions (not just reference)
        // Why? Prevents external code from modifying our block's data
        this.transactions = new ArrayList<>(transactions);

        // Get current time in milliseconds (Unix epoch time)
        this.timestamp = new Date().getTime();

        // Start with nonce = 0, will increment during mining
        this.nonce = 0;

        // Calculate merkle root (represents all transactions as single hash)
        this.merkleRoot = calculateMerkleRoot();

        // Calculate initial hash (will be recalculated many times during mining)
        this.hash = calculateHash();
    }

    /**
     * Calculate hash for this block (the block's unique fingerprint)
     * ============================================================
     *
     * How it works:
     * 1. Combine all block data into one string
     * 2. Run SHA-256 hash function on that string
     * 3. Result: 64-character hexadecimal string
     *
     * Why this matters:
     * - Changing ANY data (even 1 bit) produces completely different hash
     * - This is how blockchain detects tampering!
     * - Example: If someone changes a transaction, hash won't match
     *
     * What gets hashed:
     * - index: Block number
     * - previousHash: Link to previous block
     * - timestamp: When block was created
     * - nonce: Random number (changes during mining)
     * - merkleRoot: Fingerprint of all transactions
     *
     * @return 64-character hash string (e.g., "000012ab34cd...")
     */
    public String calculateHash() {
        // Concatenate all block data into single string
        String data = Integer.toString(index) +
                previousHash +
                Long.toString(timestamp) +
                Integer.toString(nonce) +
                merkleRoot;

        // Apply SHA-256 cryptographic hash function
        // Returns 64-character hexadecimal string
        return StringUtil.applySha256(data);
    }

    /**
     * Mine this block using Proof-of-Work algorithm
     * ============================================
     *
     * WHAT IS MINING?
     * Mining is the process of finding a hash that meets difficulty requirements.
     * It's like a lottery where miners keep trying different numbers (nonces)
     * until they find one that produces a hash starting with enough zeros.
     *
     * WHY MINE?
     * - Secures the blockchain (makes tampering extremely expensive)
     * - Controls block creation rate (Bitcoin: ~10 minutes per block)
     * - Prevents spam (costs real computational power)
     *
     * HOW IT WORKS:
     * 1. Set target (e.g., difficulty=4 means hash must start with "0000")
     * 2. Try nonce = 0, calculate hash
     * 3. Hash doesn't match? Try nonce = 1, calculate hash
     * 4. Repeat until hash starts with "0000..."
     * 5. Success! Block is mined
     *
     * DIFFICULTY EXAMPLES:
     * - Difficulty 1: Hash starts with "0" (easy, ~16 attempts average)
     * - Difficulty 2: Hash starts with "00" (~256 attempts average)
     * - Difficulty 4: Hash starts with "0000" (~65,536 attempts average)
     * - Difficulty 10: Hash starts with "0000000000" (billions of attempts!)
     *
     * Real Bitcoin uses difficulty ~19 (takes specialized hardware!)
     *
     * @param difficulty - Number of leading zeros required in hash
     */
    public void mineBlock(int difficulty) {
        // Create target string: difficulty=4 ‚Üí target="0000"
        // This is what the start of our hash must match
        String target = StringUtil.getDifficultyString(difficulty);

        // Print mining header (visual feedback for user)
        System.out.println("=".repeat(70));
        System.out.println("‚õèÔ∏è  MINING BLOCK #" + index + " (Difficulty: " + difficulty + ")");
        System.out.println("=".repeat(70));
        System.out.println("Target: Hash must start with " + target);
        System.out.println("Transactions in block: " + transactions.size());
        System.out.println();

        // Record start time (so we can calculate how long mining took)
        long startTime = System.currentTimeMillis();

        // THE MINING LOOP - This is where the "work" happens!
        // Keep trying different nonces until we find valid hash
        while (!hash.substring(0, difficulty).equals(target)) {
            // Increment nonce (try next number)
            nonce++;

            // Recalculate hash with new nonce
            // Remember: changing nonce changes hash completely!
            hash = calculateHash();

            // Print progress every 10,000 attempts (so user knows it's working)
            // Without this, screen would be blank for a long time
            if (nonce % 10000 == 0) {
                System.out.println("[MINING] Trying nonce: " + nonce + " | Hash: " + hash.substring(0, 10) + "...");
            }
        }
        // Loop exits when: hash starts with required number of zeros!

        // Calculate how long mining took
        long endTime = System.currentTimeMillis();
        double miningTime = (endTime - startTime) / 1000.0; // Convert to seconds

        // Print success message with mining statistics
        System.out.println();
        System.out.println("‚úÖ‚úÖ‚úÖ BLOCK MINED SUCCESSFULLY! ‚úÖ‚úÖ‚úÖ");
        System.out.println("‚îÅ".repeat(70));
        System.out.println("üì¶ Block #" + index + " Details:");
        System.out.println("   Nonce Found:     " + nonce);
        System.out.println("   Final Hash:      " + hash);
        System.out.println("   Mining Time:     " + miningTime + " seconds");
        System.out.println("   Total Attempts:  " + nonce);
        System.out.println("‚îÅ".repeat(70));
        System.out.println();
    }

    /**
     * Calculate Merkle Root from all transactions
     * ==========================================
     *
     * WHAT IS A MERKLE TREE?
     * A binary tree of hashes that provides a single hash representing
     * all transactions in the block. Named after Ralph Merkle.
     *
     * WHY USE MERKLE TREES?
     * 1. Efficient verification: Can prove a transaction is in block without
     *    downloading all transactions (useful for light clients)
     * 2. Integrity: If any transaction changes, merkle root changes
     * 3. Space efficient: One hash represents thousands of transactions
     *
     * HOW IT WORKS (Example with 4 transactions):
     *
     *                    ROOT (Merkle Root)
     *                    /              \
     *            H(H1+H2)                H(H3+H4)
     *            /      \                /      \
     *          H1       H2             H3       H4
     *          |        |              |        |
     *         T1       T2             T3       T4
     *
     * Process:
     * 1. Start with transaction IDs as leaf nodes
     * 2. Hash pairs of nodes together
     * 3. If odd number, duplicate last node
     * 4. Repeat until only one hash remains (the root)
     *
     * @return Merkle root hash (single hash representing all transactions)
     */
    private String calculateMerkleRoot() {
        // Edge case: If no transactions, return "0"
        // (Genesis block might have no transactions)
        if (transactions == null || transactions.isEmpty()) {
            return "0";
        }

        // STEP 1: Start with transaction IDs as the bottom layer (leaves)
        // Each transaction has a unique ID (its hash)
        List<String> treeLayer = new ArrayList<>();
        for (Transaction transaction : transactions) {
            treeLayer.add(transaction.getTransactionId());
        }

        // STEP 2: Build tree upward by hashing pairs until we reach the root
        // Continue until we have just one hash left (the merkle root)
        while (treeLayer.size() > 1) {
            List<String> newTreeLayer = new ArrayList<>();

            // Hash pairs of nodes from current layer
            for (int i = 0; i < treeLayer.size(); i += 2) {
                if (i + 1 < treeLayer.size()) {
                    // We have a pair: hash them together
                    // Example: H(node[0] + node[1])
                    String combined = treeLayer.get(i) + treeLayer.get(i + 1);
                    newTreeLayer.add(StringUtil.applySha256(combined));
                } else {
                    // Odd number of nodes: duplicate the last one
                    // Example: If we have 3 nodes, hash node[2] with itself
                    // This maintains tree structure: H(node[2] + node[2])
                    String combined = treeLayer.get(i) + treeLayer.get(i);
                    newTreeLayer.add(StringUtil.applySha256(combined));
                }
            }

            // Move up to next layer of tree
            treeLayer = newTreeLayer;
        }

        // Return the final hash (top of tree - the merkle root)
        // This single hash represents ALL transactions in block
        return treeLayer.get(0);
    }

    // ============================================================
    // GETTER METHODS - Allow controlled access to block data
    // ============================================================
    // Note: No setters! Once created, blocks should be immutable
    // (except for nonce and hash during mining)

    public int getIndex() {
        return index;
    }

    public long getTimestamp() {
        return timestamp;
    }

    public String getHash() {
        return hash;
    }

    public String getPreviousHash() {
        return previousHash;
    }

    public int getNonce() {
        return nonce;
    }

    public List<Transaction> getTransactions() {
        return transactions;
    }

    public String getMerkleRoot() {
        return merkleRoot;
    }

    /**
     * String representation for printing (human-readable format)
     *
     * Instead of printing full 64-character hashes (too long),
     * we show just the first 16 characters followed by "..."
     *
     * Example output:
     * Block #3 [hash=000012ab34cd56ef..., prevHash=000087fe65dc43ba..., txCount=5, nonce=47582]
     */
    @Override
    public String toString() {
        return "Block #" + index + " [" +
                "hash=" + hash.substring(0, 16) + "..." +
                ", prevHash=" + previousHash.substring(0, 16) + "..." +
                ", txCount=" + transactions.size() +
                ", nonce=" + nonce +
                "]";
    }
}